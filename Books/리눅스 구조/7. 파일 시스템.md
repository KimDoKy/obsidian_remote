---
tags:
  - book
  - linux
---
각종 장치는 디바이스 파일로 접근 가능하다.
하지만 대부분의 저장 장치는 파일 시스템으로 접근한다.

파일 형식으로 데이터를 관리하는 저장 장치의 영역
해당 저장 영역을 다루는 처리 양쪽을 모두 합쳐서 파일 시스템이라고 부름

디렉터리 라는 특수한 파일을 사용하여 각 파일을 분류한다.

- 데이터
사용자가 작성한 문서, 영상, 프로그램 등에 해당
- 메타 데이터
파일을 관리할 목적으로 파일 시스템에 존재하는 부가적인 정보

- 주요 메타 데이터

| 종류                       | 내용                                       |
| -------------------------- | ------------------------------------------ |
| 파일 이름                  | -                                          |
| 저장 장치에서의 위치, 크기 | -                                          |
| 파일 종류                  | 일반 파일, 디렉터리, 디바이스 파일 등      |
| 파일 시각 정보             | 작성 날짜, 최종 접근 날짜, 최종 수정 날짜  |
| 파일 권한 정보             | 어떤 사용자가 파일에 접근 가능한가         |
| 디렉터리 데이터            | 디렉터리 내부에 어떤 파일이 들어 있는가 등   |

## 파일 접근 방법

파일 시스템에는 POSIX에서 정함 함수로 접근한다.
- 파일 조작
	- 작성, 삭제: creat(), unlink(), 등
	- 열고 닫기: open(), close, 등
	- 읽고 쓰기: read(), write(), mmap(), 등
- 디렉터리 조작
	- 작성, 삭제: mkdir(), rmdir()
	- 현재 디렉터리 변경: chdir()
	- 열고 닫기: opendir(), closedir()
	- 읽기: readdir()

파일 시스템 조작용 함수를 호출시 처리 순서
1. 파일 시스템 조작용 함수가 내부적으로 파일 시스템을 조작하는 시스템 콜을 호출함
2. 커널 내부 가상 파일 시스템(VFS) 처리가 동작하고 각각의 파일 시스템 처리를 호출함
3. 파일 시스템 처리가 디바이스 드라이버를 호출함
4. 디바이스 드라이버가 장치를 조작

---
## 메모리 맵 파일
파일 영역을 가상 주소 공간에 매핑하는 기능
mmap() 함수를 특정한 방법으로 호출하면 파일 내용을 메모리로 읽어서 그 영역을 가상 주소 공간에 매핑할 수 있다.
메모리 맵에 저장된 파일은 메모리와 같은 방법으로 접근할 수 있다.

```bash
## filemap 프로그램 동작
$ echo hello > testfile
1. 프로세스 메모리 맵 상황(/proc/<pid>/maps 출력)을 표시
2. testfile 파일을 열어서 파일을 mmap()으로 메모리 공간에 매핑
3. 프로세스 메모리 맵 상황을 다시 표시
4. 맵핑된 영역의 데이터를 hello에서 HELLO로 변경
```

```bash
root@01e1478c8494:/app# go build filemap.go
root@01e1478c8494:/app# ./filemap
*** testfile 메모리 맵 이전의 프로세스 가상 주소 공간 ***
00010000-000b0000 r-xp 00000000 00:89 23855287                           /app/filemap
000b0000-00187000 r--p 000a0000 00:89 23855287                           /app/filemap
00190000-001a7000 rw-p 00180000 00:89 23855287                           /app/filemap
001a7000-001c5000 rw-p 00000000 00:00 0
4000000000-4004000000 rw-p 00000000 00:00 0
ffffabc9d000-ffffadf4e000 rw-p 00000000 00:00 0
ffffadf4e000-ffffadf50000 r--p 00000000 00:00 0                          [vvar]
ffffadf50000-ffffadf51000 r-xp 00000000 00:00 0                          [vdso]
fffffccb7000-fffffccd8000 rw-p 00000000 00:00 0                          [stack]

testfile을 매핑한 주소: 0xffffabc9c000  # mmap() 함수 실행에 성공해서 testfile 파일 데이터 시작 주소

*** testfile 메모리 맵 이휴의 프로세스 가상 주소 공간 ***
00010000-000b0000 r-xp 00000000 00:89 23855287                           /app/filemap
000b0000-00187000 r--p 000a0000 00:89 23855287                           /app/filemap
00190000-001a7000 rw-p 00180000 00:89 23855287                           /app/filemap
001a7000-001c5000 rw-p 00000000 00:00 0
4000000000-4004000000 rw-p 00000000 00:00 0
ffffabc9c000-ffffabc9d000 rw-s 00000000 00:89 23854407                   /app/testfile  # 이 주소ㅣㅁ로 시작하는 영역이 실제로 메모리 매핑도
ffffabc9d000-ffffadf4e000 rw-p 00000000 00:00 0
ffffadf4e000-ffffadf50000 r--p 00000000 00:00 0                          [vvar]
ffffadf50000-ffffadf51000 r-xp 00000000 00:00 0                          [vdso]
fffffccb7000-fffffccd8000 rw-p 00000000 00:00 0                          [stack]
root@01e1478c8494:/app# cat testfile
HELLO  # 실제로 파일 내용이 변경된 걸 확인
```

---
## 일반적인 파일 시스템
	
- 주요 파일 시스템

| 파일 시스템 | 특징                                                      |
| ----------- | --------------------------------------------------------- |
| ext4        | 예전부터 리눅스에서 사용하던 ext2, ext3에서 전환하기 편함 |
| XFS         | 뛰어난 확장성                                             |
| Btrfs       | 풍부한 기능                                                          |

차이점
- 파일 시스템 최대 크기
- 파일 최대 크기
- 최대 파일 개수
- 파일명 최대 길이
- 동작별 처리 속도
- 표준 기능 이외의 추가 기능 유무

---
## 쿼터(용량 제한)

파일 시스템 용량을 무제한 사용하다 다른 기능 실행에 필요한 용량이 부족해지는 경우, 특히 시스템 관리용 처리에 필요한 용량이라면 시스템 전체가 불안정해진다.
이런 문제를 방지하기 위해 용도별로 사용 가능한 파일 시스템 용량을 제한하는 기능 -> 쿼터

- 사용자 쿼터
파일 소유자인 사용자마다 용량을 제한함
ext4, XFS는 사용자 쿼터 기능 사용 가능
- 디렉터리 쿼터(프로젝트 쿼터)
특정 디렉터리마다 용량을 제한함
ext4, XFS에서 사용 가능
- 서브 볼륨 쿼터
파일 시스템 내부의 서브 볼륨 단위마다 용량을 제한함
Btrfs가 서브 볼륨 쿼터 기능을 사용함

---
## 파일 시스템 정합성 유지
ext4, XFS는 저널링
Btrfs는 카피 온 라이트 으로 파일 시스템 오류를 방지한다.

### 저널링을 사용한 오류 방지
파일 시스템 내부에 저널 영역이라고 하는 특수한 메타 데이터 영역을 준비한다.
파일 시스템 갱신 방법
1. 갱신에 필요한 아토믹한 처리 목록을 일단 저널 영역에 기록한다. 이 목록을 저널로그라고 한다.
2. 저널 영역에 기록된 내용에 따라 실제로 파일 시스템 내용을 갱신한다.
저널 로그를 갱신하던 중 강제로 전원이 끊기면 단순히 저널 로그를 버리기만 하면 되기에, 실제 데이터는 처리 전 상태와 변함이 없다.

### 카피 온 라이트로 오류 방지
ext4나 XFS는 파일을 갱신시 저장 장치의 동일한 위치에 데이터를 작성한다.
Btrfs 같은 카피 온 라이트 형식의 파일 시스템은 갱신할 때마다 다른 장소에 데이터를 작성한다.

파일 이동 같은 작업은 갱신한 데이터를 다른 장소에 먼저 작성하고 링크를 재작성하는 순서로 이루어진다.
처리 중 전원이 끊기는 일이 발생해도 재식작 후에 그 전에 만들어고 있던 중간 데이터를 삭제하면 오류는 발생하지 않는다.

### 백업
정기적인 백업으로 복원하는 것이 일반적이다.

정기적인 백업이 어렵다면 복구용 명령어로 복구 할 수 있다.
파일 시스템에 따라 복구용 명령어가 다르지만, 모든 파일 시스템에는 fsck 명령어가 있다.
- ext4: fsck.ext4
- XFS: xfs_repaire
- Btrfs: btrfs check
하지만 추천하지는 않음
- 정합성 확인 및 복구를 위해 파일 시스템 전체를 검사하므로 파일 시스템 사용량에 따라 필요한 시간이 늘어남. 수 TiB 파일 시스템이라면 며칠 단위로 걸리기도 함
- 복구 검사에 오랜 시간을 들여도 결국 실패로 끝나는 경우가 많음
- 사용자가 원하는 상태로 복구된다는 보장이 없음. 데이터 오류가 발생한 파일 시스템을 억지로 마운트 가능하게 만드는 명령어에 불구하기 때문. 복구 처리 중에 오류가 생긴 데이터나 메타 데이터를 가차없이 삭제한다.

---
## Btrfs가 제공하는 파일 시스템의 고급 기능
### 스냅샷
데이터 전체 복사가 아니라, 데이터를 참조하는 메타 데이터 작성만으로 끝나므로 일반 복사 작업보다 훨씬 빠르다.
원본 파일 시스템과 데이터를 공유하므로 차지하는 공간도 줄어든다.
Btrfs의 카피 온 라이트 방식을 사용한 데이터 갱신 특성을 최대한으로 활용한 기능이다.

스냅샷은 원본 파일 시스템과 데이터를 공유하기에 공유한 데이터에 문제가 생기면 스냅샷에도 문제가 생긴다.
따라서 스냅샷은 백업 목적이 아니다. 백업을 작성하려면 스냅샷  후 해당 데이터를 별도로 다른 곳에 복사해야 한다.

### 멀티 볼륨
ext4, XFS는 1개의 파티션에 1개의 파일 시스템을 작성한다.
Btrfs는 1개 이상의 장치와 파티션으로 커다란 저장소 풀(storage pool)을 만들어서 거기에 마운트 가능한 서브 볼륨(subvolume) 영역을 작성한다.
저장소 풀은 Logical Volume Manager(LVM)에서 다루는 볼륨 그룹과 비슷하고, 서브 볼륨은 LVM의 논리 볼륨과 파일 시스템을 합친 것에 가깝다.

Btrfs는 LVM처럼 RAID 구성도 가능하다.

---
## 데이터 손상 감지와 복구
Btrfs는 체크섬을 통해 데이터 손상을 감지한다.
레이드 구성을 했다면 손상된 데이터를 우너상 복구할 수 있다.

---
## 기타 파일 시스템
### 메모리 기반의 파일 시스템
tmpfs: 저장 장치 대신 메모리를 사용해서 작성
전원이 꺼지만 사라지지만 저장 장치에 접근할 필요가 없어서 접근 속도가 빠르다.

```bash
root@01e1478c8494:/app# mount | grep ^tmpfs
tmpfs on /dev type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /sys/firmware type tmpfs (ro,relatime)

# free의 shared는 tmpfs 등에서 실제로 사용된 메모리 용량이다.
root@01e1478c8494:/app# free
              total        used        free      shared  buff/cache   available
Mem:        8040056      506304      957724      341856     6576028     6989180
스왑:     1048572        1808     1046764
```
tmpfs가 사용하는 메모리는 파일 시스템 작성과 동시에 전부 확보하는게 아니라, 데이터에 처음으로 접근했을 때 페이지 단위로 메모리를 확보하는 구조이다.

### 네트워크 파일 시스템
Network File System(NFS), Commen Internet File System(CIFS)은 원격 호스트에 있는 파일 시스템을 로컬에 있는 파일 시스템처럼 조작할 수 있다.
NFS는 리눅스를 포함한 유닉스 계통 OS의 원격 파일 시스템에 접근할 때 사용
CIFS는 윈도우 기반의 파일 시스템에 접근할 때 사용

CephFS: 여러 기기의 저장 장치를 하나로 묶어서 커다란 파일 시스템으로 구성

### procfs
procfs: 시스템에 있는 프로세스 관련 정보를 얻기 위한 파일 시스템
보통 /proc 에 마운트된다.

```bash
root@01e1478c8494:/app# ls /proc/$$
attr        coredump_filter  gid_map    mountinfo   oom_score_adj  sessionid     status          wchan
autogroup   cpuset           io         mounts      pagemap        setgroups     syscall
auxv        cwd              limits     mountstats  personality    smaps         task
cgroup      environ          loginuid   net         projid_map     smaps_rollup  timens_offsets
clear_refs  exe              map_files  ns          root           stack         timers
cmdline     fd               maps       oom_adj     sched          stat          timerslack_ns
comm        fdinfo           mem        oom_score   schedstat      statm         uid_map
```

- /proc/pid/ 이하 파일(일부)

| 파일명              | 의미                                                                   |
| ------------------- | ---------------------------------------------------------------------- |
| `/proc/<pid>/maps`    | 프로세스 메모리 맵                                                     |
| `/proc/<pid>/cmdline` | 프로세스 명령줄 인수                                                   |
| `/proc/<pid>/stat`    | 프로세스 상태<br>지금까지 사용한 CPU 시간, 우선도, 사용 메모리 용량 등 |

- /proc/ 이하 파일(일부)

| 파일명                          | 의미                                |
| ------------------------------- | ----------------------------------- |
| `/proc/cpuinfo`                 | 시스템에 설치된 CPU 관련 정보       |
| `/proc/diskstat`                | 시스템에 설치된 저장 장치 관련 정보 |
| `/proc/memoinfo`                | 시스템 메모리 관련 정보             |
| `/proc/sys/`<br>디렉터리 이하 파일 | 커널의 각종 튜닝 파라미터<br>sysctl 명령어와 /etc/sysctl.conf로 변경하는 파라미터와 1:1 관계                                    |

ps, sar, free 같은 명령어처럼 OS가 제고ㅇ하는 각종 정보는 procfs에서 정보를 수집한다.
### sysfs

procfs는 프로세스 관련 정보 이외에도 커널이 관리하는 정보를 재한 없이 저장하는 문제가 발생함
procrfs를 남용하지 않도록 이러한 정보를 모아둘 장소를 만든 것이 sysfs이다.
보통 /sys/ 디렉터리 아래에 마운트된다.

- 블록 장치의 sysfs 파일(일부)

| 파일             | 설명                                                                                        |
| ---------------- | ------------------------------------------------------------------------------------------- |
| removable        | CD, DVD 같은 장치에서 미디어를 꺼낼 수 있으면 1,  아니면 0                                  |
| ro               | 1이면 읽기 전용, 0이면 쓰기도 가능                                                          |
| size             | 장치 크기                                                                                   |
| queue/rotational | 접근할 때 디스크처럼 회전이 필요한 HDD, CD, DVD는 1<br>회전이 필요치 않은 SSD 같은 기기면 0 |
| nvme0n1p<n>      | 파티션에 대응하는 디렉터리. 각 디렉터리에는 위에서 설명한 파일들이 존재                                                                                            |

---
#linux 
---
tags:
  - book
  - linux
---
## 빠른 프로세스 작성 처리
### fork() 함수 고속화: 카피 온 라이트
부모 프로세스의 메모리를 자식 프로세스에 모두 복사하는 것이 아니라 페이지 테이블만 복사한다.
페이지 테이블 엔트리 내부에는 페이지에 쓰기 권한을 관리하는 필드가 있는데, 이때 부모와 자식 양쪽을 대상으로 모든 페이지에 쓰기 권한을 무효화한다.
이후 메모리를 읽을 때 부모와 자식 사이에 공유된 물리 페이지에 접근 가능하다.
부모와 자식 중 어느 쪽에서 데이터를 갱신하려고 하면 페이지 공유를 해제하고, 프로세스마다 전용 페이지를 만든다.
자식 프로세스가 페이지 데이터를 갱신하려고 하면 일어나는 일
- 쓰기 권한이 없기에 CPU에서 페이지 폴트가 발생
- CPU가 커널 모드로 바뀌고 커널의 페이지 폴트 핸들러가 동작
- 페이지 폴트 핸들러는 접속한 페이지를 별도의 물리 메모리에 복사
- 자식 프로세스가 변경하려 했던 페이지에 해당하는 페이지 테이블 엔트리를 부모와 자식 프로세스를 대상으로 모두 변경
 Copy on Wirte(CoW): fork() 함수를 호출할 때가 아니라 이후에 각 페이지에 처음으로 쓰기를 할 때 데이터를 복사하는 방식
 - fork() 함수를 호출한 순간에는 모든 메모리를 전부 복사하지 않기 때문에 fork() 함수 처리가 빨라지고 메모리 사용량도 줄어든다.
 - 프로세스를 생성해도 모든 메모리에 쓰기 작업이 발생하는 일이 흔지 않기에 시스템 전체 메모리 사용량도 줄어든다.
 페이지 폴트에서 복귀한 자식 프로세스는 데이터를 변경한다.
 
### execve() 함수의 고속화: Demand paging
execve() 함수 호출 직후에도 프로세스용 물리 메모리는 아직 할당되지 않는다.
이후에 프로그램이 엔트리 포인트에서 실행을 시작히면 엔트리 포인트에 대응하는 페이지가 존재하지 않기에 페이지 폴트가 발생한다.
페이지 폴트 처리 결과가 프로세스에 물리 메모리가 할당된다.
다른 페이지에 접근할 때마다 각각 같은 흐름으로 물리 메모리가 할당된다.

---
## 프로세스 통신
### 공유 메모리
Copy on Write 기능으로 fork() 함수 호출 직후에는 물리 메모리를 공유하고 있지만 쓰기 작업을 하면 별도의 메모리가 할당된다.
공유 메모리 방식을 사용하면 여러 프로세스에 동일한 메모리 영역을 매핑할 수 있다.

### 시그널
시그널을 사용해서 두 프로세스가 서로 시그널을 주고받으며 진행 정도를 확인하면서 처리를 진행할 수 있다.
다만 시그널은 워시적인 구조라서 시그널 신호를 받는 쪽으로는 시그널 도착 여부 같은 정보 밖에 보낼 수 없기 때문에 제약이 많다.
그래서 단순한 일을 할 때만 사요앟ㄴ다.

dd 명령어에 SIGUSR1을 보내면 진척 상황을 표시한다.

### 파이프

양방향 통신도 가능하고 파일을 사용해서 프로세스를 연결하는 등 다양한 일을 할 수 있다.

### 소켓
리눅스는 프로세스끼리 소켓으로 연결해서 통신할 수 있다.
- 유닉스 도메인 소켓(UNIX domain socket)
같은 기기에 있는 프로세스 사이에서만 통신하는 방법
- TCP 소켓, UDP 소켓
인터넷 프로토콜 스위트 또는 TCP/IP 프로토콜에 따라서 여러 프로세스와 통신함
유닉스 도메인 소켓보다는 느리지만 다른 기기에 있는 프로세스와 통신이 가능함

---
## 배타적 제어(exclusive control)
시스템에 존재하는 자원 중 동시에 접근하면 안되는 것들에 대해 한 번에 하나의 처리만 접근 가능하게 관리하는 것

- 크리티컬 섹션(인계 구역): 동시에 실행되면 안되는 처리 흐름
- 아토믹 처리: 시스템 외부에서 봤을 때 하나의 처리로 다루어야 하는 처리 흐름

lock 파일 존재를 확인하고 파일을 작성하는 처리 흐름이 중간에 끼어들 수 없도록 모두 아토믹 처리되어야 한다.
File lock은  flock() 이나 fntl() 시스템 콜을 사용해서 파일의 lock/unlock 상태를 변경한다.

---
## 돌고 도는 배타적 제어

File lock은 기계어 계층에서 구현한다.

ref keyword: compare and exchange, compare and swap

고급 언어 수준에서 배타적 제어를 할 수 있지만, CPU 명령을 사용할 때보다 시간도 걸리고 메모리도 많이 사용하는 문제가 있다.
ref keyword: 피터슨의 알고리즘(Peterson's algorithm)
---
## 멀티 프로세스와 멀티 스레드
병렬 동작시키는 방법
- 전혀 다른 일을 하는 여러 프로그램을 동시에 동작시키는 것
- 어떤 목적을 지닌 하나의 프로그램을 여러 개의 흐름으로 분할해서 실행하는 것
	- 멀티 프로세스: fork()나 execve() 함수를 사용해서 필요한 만큼 프로세스를 생성하고 이후에 각자 프로세스끼리 통신 기능을 사용해서 처리
	- 멀티 스레드: 멀티 스레드는 프로세스 내부에 여러 개의 흐름을 작성
		- 장점
			- 페이지 테이블 복사가 필요 없어서 생성 시간이 짧음
			- 다양한 자원을 동일한 프로세스 내부의 모든 스레드가 공유하므로 메모리를 비롯한 자원 소비량이 적음
			- 모든 스레드가 메모리를 공유하므로 혀베조해서 동작하기 쉬움
		- 단점
			- 하나의 스레드에서 발생한 장애가 모든 스레드에 영향을 준다. 만약 하나의 스레드가 비정상적인 주소를 참조해서 이상 종료하면 프로세스 전체가 이상 종료한다.
			- 각 스레드에서 호출하는 처리가 멀티 스레드 프로그램에서 불러도 문제 없는지(스레드 세이프) 미리 알고 있어야 한다. 예를 들어 내부적으로 전역 변수를 배타적 재어없이 접근하는 처리는 스레드 세이프가 아니다. 따라서 한 번에 하나의 스레드에서만 해당하는 처리를 다루도록 개발자가 제어해야 한다.

---

스레드 구현 방법
- 커널 스레드
	- ps -eLF 로 목록을 확인
	- LWP는 커널 스레드에 할당된 ID. 프로세스 생성 시 만들어진 LWP ID는 PID와 동일하다.
	- clone() 시스템 콜을 사용
- 사용자 스레드
	- clone() 시스템 콜을 사용하지 않는다.
	- 스레드 라이브러리를 가지고 구현함

스레드 정보 관리
- 커널 스레드: 커널
- 사용자 스레드: 프로세스

커널 스레드는 논리 CPU가 여러 개일 때 동시 실헹이 가능하다는 장점이 있지만,
생성 비용, 스레드 실행 전환 비용은 사용자 스레드가 낮다.

---
#linux
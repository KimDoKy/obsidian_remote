---
tags:
  - book
  - linux
---
## 디바이스 파일
디바이스 파일은 장치마다 존재한다.
/dev/sda, /dev/sdb 같은 파일이 디바이스 파일이다. (파티션마다 디바이스 파일이 존재한다)
프로세스가 디바이스 파일을 조작하려면 커널 내부의 디바이스 드라이버라는 소프트웨어가 사용자 대신 장치에 접근한다.

프로세스는 open(), read(), write() 같은 시스템 콜을 호출해서 각각의 장치에 접근한다.
장치 고유의 복잡한 조작은 ioctl() 시스템 콜을 사용한다.
디바이스 파일에 접근 가능한건 보통 루트뿐이다.

디바이스 파일 정보
- 파일 종류: 캐릭터 장치 또는 블록 장치
- 디바이스 메이저 번호, 마이너 번호

디바이스 파일 조회
```bash
$ ls -l /dev/
```
- c: 캐릭터 장치
- b: 블록 장치
- 5번째 필드: 메이저 번호
- 6번째 필드: 마이너 번호

### 캐릭터 장치

읽고 쓰기는 가능하지만, 장치 내부에서 접근할 장소를 변경하는 탐색 조작은 불가능
- ex: 단말, 키보드, 마우스

```bash
각 프로세스와 연결된 단말 확인
root@01e1478c8494:/app# ps ax
  PID TTY      STAT   TIME COMMAND
    1 pts/0    Ss     0:02 bash
17118 pts/0    R+     0:00 ps ax

bash는 pts/0 단말을 사용
```

### 블록 장치

파일 읽기 쓰기뿐만 아니라 탐색도 가능
- ex: HDD, SDD같은 저장 장치
사용자가 블록 디바이스 파일을 직접 조작하는 건 극히 드뭄.보통 파일 시스템을 경유해서 데이터를 읽고 씀
- 프로세스가 디바이스 파일을 사용해서 디바이스 드라이버에 장치를 조작하고 싶다고 요청
- CPU가 커널 모드로 전환되고 디바이스 드라이버가 레지스터를 사용해서 장치에 요청을 전달
- 장치가 요청에 따라 처리
- 디바이스 드라이버가 장치의 처리 완료를 확인하고 결과를 받음
- CPU가 사용자 모드로 전환되고 프로세스가 디바이스 드라이버 처리 완료를 확인해서 결과를 받음

---
## 디바이스 드라이버

장치를 직접 조작하려면 각 장치에 내장된 레지스터 영역을 읽고 써야 한다.
CPU 레지스터와는 완전히 다르다.

### 메모리 맵 입출력(MMIO)

현대적인 장치는 MMIO 구조를 사용해서 디바이스 레지스터에 접근한다.
x86_64 아키텍처는 리눅스 커널이 자신의 가상 주소 공간에 물리 메모리를 모두 매핑한다.
MMIO로 장치를 조작한다면 주소 공간에 메모리뿐만 아니라 레지스터도 매핑한다.

| 레지스터 오프셋 | 역할                                                        |
| --------------- | ----------------------------------------------------------- |
| 0               | 읽고 쓰기에 사용하는 메모리 영역 시작 주소                  |
| 10              | 저장 장치 내부의 읽고 쓰기에 사용하는 데이터 영역 시작 주소 |
| 20              | 읽고 쓰기 크기                                              |
| 30              | 처리 요청에 사용. 0이면 읽기 요청, 1이면 쓰기 요청          |
| 40                |  요청한 처리가 끝났는지 여부를 나타내는 플래스<br>처리를 요청한 시점에 0이 되고 처리가 끝나면 1이 됨                                                           |

처리 완료를 확인하려면 폴링이나 인터럽트 중 하나를 사용한다.

### 폴링

디바이스 드라이버가 능동적으로 장치에서 처리를 완료했는지 확인한다.
장치 디바이스 드라이버가 요청한 처리를 완료하면 처리 완료 통지용 레지스터의 값을 변화시킨다.
디바이스 드라이버는 이 값을 주기적으로 읽어서 처리 완료를 확인한다.
장치에서 처리가 끝나서 디바이스 드라이버가 완료를 확인할 때까지 CPU는 확인 작업 외에는 다른 일을 할 수 없다.
시간 낭비를 줄이기 위해 계속해서 장치 처리 완료를 확인하는 대신, 일정 간격을 두고 레지스터 값을 확인하는 폴링 방법을 사용할 수 있다.

### 인터럽트

디바이스 드라이버가 장치에 처리를 요청한다. 이후 CPU는 다른 처리를 실헹한다.
장치가 처리를 완료하면 인터럽트 방식으로 CPU에 알린다.
CPU는 미리 디바이스 드라이버가 인터럽트 컨트롤러 하드웨어에 등록해둔 인터럽트 핸들러 처리를 호출한다.
인터럽트 핸들러가 장치의 처리 결과를 받는다.

- 장치 처리가 완료할 때까지 CPU는 다른 프로세스를 실행할 수 있다.
- 장치 처리 완료를 즉시 확인 가능하다.
- 장치에서 처리가 이뤄지는 동안 동작하는 프로세스는 장치에서 무슨 일이 일어나고 있는지 신경 쓸 필요 없다.

이런 장점 때문에 폴링보다는 인터럽트를 더 많이 사용한다.

```bash
# 시스템 시작 이후 지금까지 발생한 인터럽트 개수 확인
root@01e1478c8494:/app# cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3
 11:    1033103    1066346    1063742    1097772     GICv3  27 Level     arch_timer
 14:          0          0          0          0     GICv3  36 Level     rtc-pl031
 15:         26          0          0          0     GICv3  65 Level     virtio0
 16:        413          0          0          0     GICv3  69 Level     virtio1
 ...
 ```

출력 결과의 하나의 줄이 하나의 IRQ(Interupt ReQuest)이다.
- 첫 번째 필드: IRQ 번호.
- 2 ~ 9번째 필드(논리 CPU 만큼 존재): IRQ 번호에 대응하는 인터럽트가 각 논리 CPU에서 발생한 횟수

요즘은 필요할 때만 타이머 인터럽트를 발생시킨다.
인터럽트 처리 횟수가 줄어서 CPU 모드 전환에 따른 성능 저하 방지나 소비 전력 절약을 한다.

장치 처리가 빠르고 처리 빈조가 높다면 예외적으로 폴링을 사용하기도 한다.
인터럽트 핸들러 호출은 어느 이상의 오버헤드가 발생하고, 장치 처리가 너무 빠르면 인터럽트 핸들러를 호출하는 사이에 인터럽트가 계속 발생해서 처리를 따라잡지 못할 위험이 있기 때문이다.
평소에 인터럽트를 사용하다 인터럽트 빈도가 높아지면 폴링으로 전환하는 디바이스 드라이버도 있다.
사용자 공간 입출력(userspace I/O, UIO): 디바이스 레지스터를 매핑한 메모리 영역을 프로세스의 가상 주소 공간에 매핑해서, 프로세스에서 장치를 조작하는 기능
UIO를 사용하면 디바이스 파일에 접근할 때마다 CPU모드가 전환되는 걸 피하여 장치 접근 속도가 빨라지는 효과를 얻을 수 있다.
ref keyword: userspace I/O(UIO), Data Plan Development Kit(DPDK), Storage Performance Development Kit(SPDK)

---
## 디바이스 파일명은 바뀌기 마련

여러 장치가 연결되어 있다면 커널은 일정한 규칙에 따라 각각 다른 이름으로 디바이스 파일(메이저 번호와 마이너 번호 조합)에 대응시킴
이런 대응 관계는 PC를 기동할 떄마다 변경된다.

바뀌는 이유
- 다른 저장 장치 추가
- 저장 장치 위치 변경
- 정장 장치 고장으로 인식되지 않을 때

이름이 바뀐다면?
- 운이 좋으면 부팅 실패 정도에서 끝
- 운이 나쁘면 데이터가 파괴됨

systemd의 udev 프로그램으로 영구 장치명(persistent device name)을 이용해서 해결할 수 있다.

단순히 마운트할 파일 시스템의 실수를 방지할 목적이라면 mount 명령어에 레이블이나 UUID를 지정할 수 있다.

---
#linux 
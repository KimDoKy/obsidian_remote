---
tags:
  - book
  - linux
  - container
---
![[Pasted image 20230922192014.png]]
## 가상 머신과 차이점
- 가상 머신의 서비스 실행 흐름
	1. 호스트 OS의 가상화 소프트웨어가 가상 머신을 기동
	2. GRUB 같은 부트 로드가 기동
	3. 부트 로더가 커널을 기동
	4. 커널이 init 프로그램을 기동
	5. init(대부분 systemd) 프로세스가 각종 서비스를 시작
- 기동 속도: 컨테이너는 가상 머신에서 필요한 처리들(1, 2, 3) 전부 생략 가능
- 하드웨어 접근 속도: 가상 머신은 하드웨어 접근에 의해 물리 기기에 제어를 넘겨야 하지만, 컨테이너는 그럴 필요가 없음
---
## 컨테이너 종류
- 시스템 컨테이너
일반 리눅스 환경처럼 다양한 애플리케이션을 실행하기 위한 컨테이너
최초 프로세스로 init 프로세스를 실행하고 init가 각종 서비스를 실행해서 다양한 애플리케이션을 동작하는 환경을 만듬
실행환경은 LXD 등이 있다.

- 애플리케이션 컨테이너
컨테이너에서 하나의 애플리케이션만 동작
하나의 애플리케이션이 동작할 환경만 포함하기 때문에 시스템 컨테이너보다 가벼움
애플리케이션 프로세스를 최초 프로세스로 직접 실행하는 경우도 많음
도커

---
## 네임스페이스
컨테이너는 네임스페이스 기능을 잘 활용하여 구현
네임스페이스: 자원들을 공유하는 것이 아니라 소속된 프로세스에 독립적 자원인 것처럼 만들어 주는 기능

- pid namespace: 독립된 pid 이름 공간을 제공
- user namespace: 독립된 uid, gid를 제공
- mount namespace: 독립된 파일 시스템 마운트를 제공

### 프로세스ID 네임스페이스
시스템을 기동하면 모든 프로세스가 소속된 루트 프로세스ID 네임스페이스가 존재한다.

```bash
# 프로세스가 소속된 프로세스 PID 네임스페이스 확인
## 별도로 지정하지 않는 한 init를 비롯한 모든 프로세스는 루트 프로세스ID의 네임스페이스에 소속된다.
azureuser@myvm:~$ sudo ls -l /proc/$$/ns/pid
lrwxrwxrwx 1 azureuser azureuser 0 Sep 22 10:52 /proc/1761/ns/pid -> 'pid:[4026531836]'

# 새로운 프로세스ID의 네임스페이스를 작성해서 프로그램 실행
## unshare: 인수로 지정한 프로그램을 새로운 네임스페이스에서 실행
## --pid: 새로운 프로세스ID의 네임스페이스를 만들어서 해당 프로세스를 새로 만든 프로세스ID의 네임스페이스에서 실행
## 새로운 프로세스ID의 네임스페이스에서는 pid가 1이 된다.
azureuser@myvm:~$ sudo unshare --fork --pid --mount-proc bash
root@myvm:/home/azureuser# echo $$
1
## 루트 프로세스ID의 네임스페이스와 ID가 다르다.
root@myvm:/home/azureuser# ls -l /proc/1/ns/pid
lrwxrwxrwx 1 root root 0 Sep 22 10:51 /proc/1/ns/pid -> 'pid:[4026532154]'
## 프로세스 목록을 확인하면 bash, ps만 나온다.
## 루트 프로세스와 다른 독자적인 프로세스 ID의 네임스페이스에 소속되어 있기 때문이다.
root@myvm:/home/azureuser# ps ax
    PID TTY      STAT   TIME COMMAND
      1 pts/1    S      0:00 bash
      9 pts/1    R+     0:00 ps ax

# host에서
## unshare의 자식인 bash가 새로운 프로세스ID의 네임스페이스에서 동작하고 있는 bash이다.
azureuser@myvm:~$ pstree -p | grep unshare
           |-sshd(1523)-+-sshd(1570)---sshd(1668)---bash(1671)---sudo(1689)---sudo(1690)---unshare(1691)---bash(1692)
## unshare의 자식 bash의 네임스페이스를 확인하면 새로운 네임스페이스이다.
azureuser@myvm:~$ sudo ls -l /proc/1692/ns/pid
lrwxrwxrwx 1 root root 0 Sep 22 10:52 /proc/1692/ns/pid -> 'pid:[4026532154]'

# 새로운 네임스페이스를 생성한다.
azureuser@myvm:~$ sudo unshare --fork --pid --mount-proc bash
root@myvm:/home/azureuser# ls -l /proc/1/ns/pid
lrwxrwxrwx 1 root root 0 Sep 22 10:54 /proc/1/ns/pid -> 'pid:[4026532156]'
root@myvm:/home/azureuser# ps ax
    PID TTY      STAT   TIME COMMAND
      1 pts/3    S      0:00 bash
      9 pts/3    R+     0:00 ps ax

# 새로운 프로세스ID 네임스페이스에서는 루트 프로세스뿐만 아니라 앞서 만든 프로세스ID의 네임스페이스에 소속된 프로세스를 참조할 수 없다.
azureuser@myvm:~$ pstree -p | grep unshare
           |-sshd(1523)-+-sshd(1570)---sshd(1668)---bash(1671)---sudo(1689)---sudo(1690)---unshare(1691)---bash(1692)
           |            |-sshd(1705)---sshd(1760)---bash(1761)---sudo(1784)---sudo(1785)---unshare(1786)---bash(1787)
```

### 컨테이너 정체
=> 독립된 네임스페이스를 가지고 다른 프로세스와 실행환경이 나뉘는 하나 또는 여러 프로세스

호스트 OS나 다른 컨테이너에서 발생한 문제가 있을때 컨테이너 내부에서는 원인을 알 수 없다.
ex. 독자적인 프로세스ID의 네임스페이스를 가진 컨테이너 내부에서 top를 통해 CPU 부하가 높은 걸 발견
이 컨테이너는 동일한 컨테이너에 있는 프로세스만 볼 수 있기 때문에, CPU 부하 원인이 호스트 OS나 다른 컨테이너라면 손 쓸 방법이 없다.

---
## 보안 위험성
컨테이너는 호스트 시스템 및 모든 컨테이너가 커널을 공유한다.
따라서 커널에 취약점이 있으면 취약한 컨테이너 사용자로 인해 호스트 OS나 다른 컨테이너 정보가 누출 될 수 있다.
가상 머신은 보통 가상 머신의 하드웨어 수준에서 끝난다.

이런 문제점 때문애 다양한 종류의 컨테이너 런타임이 생겼다.

![[Pasted image 20230922200721.png]]

---
#linux 
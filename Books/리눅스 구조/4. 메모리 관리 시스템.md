---
tags:
  - book
  - linux
---
## 메모리 관련 정보 수집하기

- free

| 필드명       | 의미                                                                                                                        |
| ------------ | --------------------------------------------------------------------------------------------------------------------------- |
| total        | 시스템에 설치된 전체 메모리 용량                                                                                            |
| free         | 명목상 비어 있는 메모리                                                                                                     |
| buff / cache | 버퍼, 캐시, 패이지 캐시가 이용하는 메모리<br/>시스템의 비어 있는 메모리(free 필드값)가 줄어들면 커널이 해제시킴                  | 
| available    | 실제로 사용 가능한 메모리. <br/>free 필드값과 비어 있는 메모리가 줄어 들었을 때 해제 가능한 커널 내부 메모리 영역 크기를 더한 값 |
| used         | 시스템이 사용 중인 메모리에서 buff/cache를 뺀 값                                                                            |

![[Pasted image 20230913072553.png]]
### used
프로세스 메모리 사용량에 따라 늘어난다.
프로세스가 종료하면 커널은 해당 프로세스의 메모리를 모두 해제한다.
프로그램 실행 중에 메모리를 사용하면 시스템 전체 메모미 사용량이 늘어난다.
메모리를 사용하던 프로세스를 종료하면 해당하는 메모리가 해제된다.

```bash
root@cbe6ede98612:/app# ./memuse.py
메모리 사용 전의 전체 시스템 메모리 사용량을 표시합니다.
              total        used        free      shared  buff/cache   available
Mem:        8040056     1087640     1963720      270580     4988696     6481140
스왑:     1048572       89160      959412
메모리 사용 후의 전체 시스템 메모리 남은 용량을 표시합니다.
              total        used        free      shared  buff/cache   available
Mem:        8040056     1161728     1889632      270580     4988696     6407052
스왑:     1048572       89160      959412
root@cbe6ede98612:/app# free
              total        used        free      shared  buff/cache   available
Mem:        8040056     1075880     1975472      270580     4988704     6492900
스왑:     1048572       89160      959412
```
### buff/cache
페이지 캐시(page cache), 버퍼 캐시(buffer cache)가 사용하는 메모리 용량
접근 속도가 느린 저장 장치에 있는 파일 데이터를 접근 속도가 빠른 메모리에 일시적으로 저장해서 접근 속도가 빨라진 것처럼 보이게 하는 커널 기능
저장 장치에 있는 파일 데이터를 읽어와서 메모리에 데이터를 캐시한다는 개념

```bash
root@cbe6ede98612:/app# ./buff-cache.sh
파일 작성 전의 시스템 전체 메모리 사용량을 표시합니다.
              total        used        free      shared  buff/cache   available
Mem:        8040056     1090836     1960264      270588     4988956     6477936
스왑:     1048572       89160      959412
1GB 파일을 새로 작성합니다. 커널은 메모리에 1GB 페이지 캐시 영역을 사용합니다.
1024+0 레코드 들어옴
1024+0 레코드 나감
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.39231 s, 145 MB/s
페이지 캐시 사용 후의 시스템 전체 메모미 사용량을 표시합니다.
              total        used        free      shared  buff/cache   available
Mem:        8040056     1084452      918228      270588     6037376     6484280
스왑:     1048572       89160      959412
파일 삭제 후, 즉 페이지 캐시 삭제 후의 시스템 전체 메모리 사용량을 표시합니다.
              total        used        free      shared  buff/cache   available
Mem:        8040056     1089328     1961632      270588     4989096     6479440
스왑:     1048572       89160      959412
```
### sar 명령어를 사용해서 메모리 관련 정보를 수집하기

free와 sar -r 의 비교

| free       | sar -r              |
| ---------- | ------------------- |
| total      | 해당 사항 없음      |
| free       | kbmemfree           |
| buff/cache | kbuffers + kbcached |
| available  | 해당 사항 없음                    |

```bash
root@cbe6ede98612:/app# sar -r 1 5
Linux 5.15.49-linuxkit (cbe6ede98612) 	2023년 09월 12일 	_aarch64_	(4 CPU)

22시 36분 15초 kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
22시 36분 16초   1958140   6475900    975276     12.13    583884   3726224   8315376     91.49   3537680   1633544         4
22시 36분 17초   1957980   6475740    975428     12.13    583884   3726224   8315376     91.49   3537680   1633516         4
22시 36분 18초   1961420   6479200    971880     12.09    583884   3726224   8315376     91.49   3537680   1633520        12
22시 36분 19초   1959392   6477176    973904     12.11    583884   3726228   8315376     91.49   3537680   1633580        16
22시 36분 20초   1961460   6479244    971856     12.09    583884   3726228   8315376     91.49   3537680   1633604        16
평균값:    1959678   6477452    973669     12.11    583884   3726226   8315376     91.49   3537680   1633553        10
```

---
## 메모리 재활용 처리
### 프로세스 삭제와 메모리 강제 해제
재활용 가능한 메모리를 해제해도 메모리 부족이 해결되지 않으면 시스템은 메모리가 부족해서 Out Of Memory(OOM) 상태가 된다.
이런 경우 메모리 관리 시스템이 적당히 프로세스를 골라서 강제 종료시키고 메모리를 비우는 OOM Killer 기능이 동작함

dmesg 으로 커널 로그를 확인할 수 있다.
```bash
[XXX] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),...
```

여러 프로세스를 실행하던 도중 예고 없이 갑자기 종료되었다면 dmesg를 확인해보면 됨.
메모리가 충분하지 않은 경우: 프로세스 개수를 줄이거나 추가 메모리 설치
메모리 용량이 충분한데?: 메모리 누수 의심. 메모리 사용량 모니터링 필요(ps aux -> RSS)

---
## 가상 메모리(virtual memory)
### 가상 메모리가 없을 때 생기는 문제점
- 메모리 단편화(Flagmentation of memory)
	- 프로그램이 메모리를 확보할 때마다 확보한 메모리가 몇 개의 영역으로 쪼개져 있는지 일일이 관리해야 하므로 무척 불편하다.  
- 멀티 프로세스 구현이 어려움
	- 사용자가 모든 프로그램의 배치 장소가 겹치지 않도록 의식해야 한다 
- 비정성적인 메모리 접근
	- 커널이나 수 많은 프로세스가 메모리에 존재할 때, 어떤 프로세스가 커널이나 다른 프로세스에 할당된 메모리 주소를 지정하면 자신이 사용하는 영역이 아님에도 불구하고 접근할 수 없는 문제가 생긴다.

### 가상 메모리 기능(Virtual Memory)
프로세스가 메모리에 접근할 때 시스템에 설치된 메모리에 직접 접근하는 대신 가상 주소를 사용해서 간접적으로 접근하는 기능

메모리의 실제 주소: 물리 주소(physical address)
물리 주소를 사용해서 접근하는 범위: 주소 공간(address space)
물리 주소를 직접 지정하는 방법은 없다.

가상 주소를 물리 주소로 변환하려면 커널 메모리 내부에 저장된 페이지 테이블을 사용한다.
CPU는 모든 메모리를 페이지 단위로 쪼개서 관리하는데, 주소는 페이지 단위로 변환된다.
페이지 테이블 엔트리(page table entry): 페이지 테이블에서 한 페이지에 대응하는 데이터
가상 주소와 물리 주소 대응 정보를 포함한다.
페이지 크기는 CPU 아키텍처에 따라 다르다.

### 가상 메모리로 문제 해결하기
- 메모리 단편화
	- 프로세스의 페이지 테이블을 잘 설정하면 물리 메모리의 단편화된 영역이라도 프로세스 가상 주소 공간에서는 커다란 하나의 영역으로 다룰 수 있다.
- 멀티 프로세스 구현이 어려움
	- 가상 주소 공간은 프로세스마다 만들어진다. 멀티 프로세스 환경에서 각자의 프로그램이 다른 프로그램과 주소가 중복되는 걸 피할 수 있다.
- 비정상적인 메모리 접근
	- 어떤 프로세스에서 다른 프로세스의 메모리로 비정상적인 접근이 불가능하다.
	- 커널 메모리도 보통 프로세스 가상 주소 공간에 매핑되지 않으므로 비정상적인 접근을 할 수 없다.
---
## 프로세스에 새로운 메모리 할당하기
### 메모리 영역 할당: mmap() 시스템 콜
동작 중인 프로세스에 새로운 메모리 영역을 할당하기 위해 사용하는 시스템 콜
커널 메모리 관리 시스템이 프로세스의 페이지 테이블을 변경하고, 요청된 크기만큼 영역을 페이지 테이블에 추가하고 매핑하고 매핑된 영역의 시작 주소를 프로세스에 돌려준다.

### 메모리 할당: Demand paging
mmap() 시스템 콜을 호출한 직후라면 새로운 메모리 영역에 대응하는 물리 메모리는 아직 존재하지 않는다.
대신에 새롭게 확보 영역 내부에 있는 각 페이지에 처음으로 접근할 때 물리 메모리를 할당한다.
이런 방식을 Demand paging이라고 한다.

보통은 프로그램을 시작할 때 mmap() 시스템 콜을 해서 어느 정도 크기의 영역을 미리 확보해서 데이터 정의를 할 때마다 이 영역에서 메모리를 나눠서 할당하고, 영역을 모두 사용했다면 다시 mmap()을 호출해서 추가로 메모리 영역을 확보하는 방식으로 동작한다.
프로그래밍 언어 번역기(인터프리터, 컴파일러 등)는 데이터 정의를 할 때마다 mmap() 시스템 콜을 호출하지 않는다.

---
## 페이지 테이블 계층화

페이지 테이블은 1차원 구조가 아니라, 메모리 소비량이 적은 계층화 구조를 사용한다.
x86_64 아키텍처라면 4단 구조 페이지 테이블을 사용하여 페이지 테이블에 필요한 메모리 용량을 크게 줄인다.
페이지 테이블이 사용하는 메모리 조회: `sar -r ALL`  -> kbpgtbl
### Huge Page

프로세스가 확보한 메모리 용량이 늘어나면 해당 프로세스의 페이지 테이블이 사용하는 물리 메모리 사용량도 늘어나는 문제를 해결한다.
Huge Page를 이용하면 프로세스의 페이지 테이블에 필요한 메모리 용량을 줄일 수 있다.
Huge Page는 mmap() 함수의 flags 인수에 MAP_HUGETLB 플래그를지정하면 사용 가능하다.
### Transparent Huge Page(THP)

가상 주소 공간 내부에 있는 연속된 여러 4KiB 페이지가 어떤 조건을 만족하면 그걸 하나로 묶어서 자동으로 Huge Page로 바꾸어주는 기능

여러 페이지를 합쳐서 하나의 Huge Page로 만드는데 들어가는 처리 비용, Huge Page를 구성하던 조건이 성립하지 않게되면 커다란 페이지를 4KiB 페이지로 다시 분할하는 처리 때문에 부분적으로 성능이 떨어지는 경우들이 있다.
그래서 THP 기능은 시스템 관리자가 선택적으로 결정한다.

설정은 /sys/kernel/mm/transparent_hugepage/enabled
- always: 시스템에 존재하는 프로세스의 모든 메모리를 대상으로 유효화한다.
- madvise: madvise() 시스템 콜에 MADV_HUGEPAGE 플래그를 설정하면 지정한 메모리 영역에서만 유효화한다.
- never: 무효화한다.

ubuntu 20.04는 기본 값이 madvise 이다 (docker image는 never이다.)

---
#linux 
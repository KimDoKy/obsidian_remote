---
tags:
  - book
  - linux
---
## 캐시 메모리
일반적으로 캐시 메모리는 CPU 내부에 존재하는 고속 기억장치이다.
메모리에서 레지스터로 데이터를 읽어 들일 때, 일단 캐시 메모리에 캐시라인(cache-line)이라고 부르는 단위로 데이터를 읽어서 그 데이터를 레지스터로 옮긴다. 캐시라인 크기는 CPU마다 정해저 있다. 이런 처리는 하드웨어에서 이뤄지기에 커널은 관여하지 않는다.

메모리에 데이터를 쓰는 방식
- 라이트 스루(write-through. 바로쓰기)
데이터를 캐시 메모리에 씀과 동시에 메모리에도 바로 기록한다.
구현이 간단하다.
- 라이트 백(wirte-back. 나중에 쓰기)
나중에 정해진 때가 되면 기록한다.
CPU에서 메모리로 데이터를 쓰는 명령어를 실행 때 곧바로 메모리에 접근하지 않아도 되므로 처리 속도가 빠르다.
캐시 메모리가 가득찬 상태로 계속해서 캐시되지 않은 메모리 영역에 접근하면, 캐시라인 내부 데이터가 빈번히 교체되는 스래싱(thrashing) 상태가 되어서 처리 성능이 떨어진다

### 참조 지역성
- 시간적 지역성(Temporal locality)
어떤 시점에 접근하는 메모리는 가까운 미래에 또다시 접근할 가능성이 높다. 반복 처리가 대표적인 예이다.
- 공간적 지역성(Spatial locality)
어떤 시점에 메모리에 접근하면 가까운 미래에 그 근처에 있는 데이터에 접근할 가능성이 높다. 배열 데이터가 전형적인 예이다.

### 계층형 캐시 메모리
L1, L2, L3 캐시
레지스터에 가장 가까이 있는 캐시가 L1 캐시
L1은 캐시 중 가장 빠르고 용량이 적다.
계층의 숫자가 늘어날수록 레지스터에서 멀어지고 용량이 늘어나지만 속도가 떨어진다.
캐시 메모리 정보는 /sys/devices/system/cpu/cpu0/cache/index0/ 디렉터리에 있는 파일 내용을 보면 알 수 있다.

- 캐시 메모리의 sysfs 파일(일부)

| 파일명                | 의미                                                                                                 |
| --------------------- | ---------------------------------------------------------------------------------------------------- |
| `type`                | 캐시할 데이터 종류<br>Data라면 데이터, Instruction이라면 코드, Unified라면 코드와 데이터 모두 캐시함 |
| `shared_cpu_list`     | 캐시를 공유하는 논리 CPU 목록                                                                        |
| `coherency_line_size` | 캐시라인 크기                                                                                        |
| `size`                | 크기                                                                                                     |

---
## Simultaneous Multi Threading(SMT)
CPU의 계산 처리 소요시간보다 메모리 접근 시간이 훨씬 더 길다.
캐시 메모리라고 해도 CPU 계산 처리에 비하면 좀 늦는 편이다.

CPU 사용 시간 중 많은 부분이 메모리 또는 캐시 메모리에서 데이터 전송을 기다리기만 하고 CPU 계산 자원은 놀고 있는 상태인 경우가 많다.
다른 이유로 놀고 있는 경우들도 많이 있다.
ex. CPU에는 정수 연산을 하는 유닛과 부동 소수점 연산을 하는 유닛이 존재하는데, 정수 연산을 하는 동안 부동 소수점 연산 유닛은 놀고 있는 상태가 된다.
이런 비어 있는 자원을 하드웨어의 SMT 기능으로 활용할 수 있다.(SMT의 스레드는 프로세스의 스레드와 별개의 단어이다)

SMT는 CPU 코어 내부에 있는 레지스터 등의 일부 자원을 여러 개 만들어서 각각을 스레드로 삼는다.
리눅스 커널은 이렇게 생성한 각 스레드를 논리 CPU로 인식한다.

---
## 페이지 캐시
CPU에서 메모리에 접근하는 속도에 비해 저장 장치에 접근하는 속도는 훨씬 느리다.
이런 속도 차이를 줄이기 위해 커널은 페이지 캐시를 사용한다.

캐시 메모리가 메모리 데이터를 캐시 메모리에 캐시하는 것처럼
페이지 캐시는 파일 데이터를 메모리에 캐시한다.
캐시 매모리는 캐시 라인이라는 단위로 데이터를 다루지만
페이지 캐시는 페이지 단위로 데이터를 다룬다.

프로세스가 파일 데이터를 읽기 시작하면 커널은 일단 커널 메모리에 있는 페이지 캐시 영역에 복사해두고, 해당 데이터를 프로세스 메로리에 복사한다.
커널은 페이지 캐시에 캐시한 영역의 관련 정보를 관리하는 영역을 커널 메모리 안에 둔다.
이 프로세스나 다른 프로세스가 페이지 캐시에 존재하는 데이터를 또 읽으면 커널은 저장 장치 대신 페이지 캐시에 있는 데이터를 리턴한다.

프로세스가 데이터를 파일에 쓰면 커널은 페이지 캐시에만 데이터를 기록한다. 저장 장치에 있는 것보다 최신이라는 표시를 한다(더티 페이지)
더티 페이지에 있는 데이터는 특정 타이밍에 저장 장치에 반영된다.(write-back)

전원이 갑자기 꺼지면?
페이지 캐시에 있던 데이터는 사라진다.
이런 일을 방지하기 위해 open() 시스템 콜로 파일을 열 때 O_SYNC 플래그를 설정한다.
이 플래그를 설정하면 write-through로 동작한다.

---
## 버퍼 캐시
디스크의 데이터 중에서 파일 데이터 이외의 것을 캐시하는 방식
- 파일 시스템을 사용하지 않고 디바이스 파일로 저장 장치에 직접 접근할 때
- 파일 크기나 권한 등의 메티 데이터에 접근할 때

버퍼 캐시도 아직 디스크에 반영하지 않은 더티 상태가 존재한다.
파일 시스템 마운트 중에는 대응하는 디바이스 파일에 접근하지 않는 것이 좋다.

---
## 쓰기 타이밍
더티 페이지는 보통 백그라운드로 동작하는 커널의 라이트 백 처리에 따라 디스크에 저장된다.
동적 타이밍 종류
- 주기적으로 동작. 기본값은 5초마다 1회
- 더티 페이지가 늘어났을 때 동작

```bash
# 라이트 백 주기 변경
## sysctl의 vm.dirty_writeback_centisecs 파라미터로 변경
## 단위는 센티초(1/100초)
## 0으로 지정하면 라이트 백이 무효화됨(설정 금지!!!)
root@01e1478c8494:/app# sysctl vm.dirty_writeback_centisecs
vm.dirty_writeback_centisecs = 500

# 바이트 단위로 지정
root@01e1478c8494:/app# sysctl vm.dirty_background_ratio
vm.dirty_background_ratio = 10

# 비율로 지정
root@01e1478c8494:/app# sysctl vm.dirty_ratio
vm.dirty_ratio = 20
```

더티 페이지가 많이 생기는 시스템에서는 메모리가 부족해서 더티 페이지의 라이트 백이 자주 발생하여 시스템이 멈추거나 OOM이 발생할 수 있다.

---
## 직접 입출력
캐시나 버퍼가 방해되는 경우
- 한 번 읽고 쓰면 두 번 다시 사용하지 않는 데이터인 경우
- 프로세스가 자체적으로 페이지 캐시에 해당하는 기능을 구현한 경우

직접 입출력(direct I/O) 방식을 사용하면 페이지 캐시 없이 처리할 수 있다.
open() 할 때 O_DIRECT 플래그를 지정한다.
iflag나 oflag에 direct 값을 지정하면 된다.

```bash
root@01e1478c8494:/app# free
              total        used        free      shared  buff/cache   available
Mem:        8040056      502356      854520      342012     6683180     6992972
스왑:     1048572        1808     1046764

## sync 옵션
### 집접 입출력을 호출하면 완료까지 기다리지 않고 복귀하기 때문
root@01e1478c8494:/app# dd if=/dev/zero of=testfile bs=1G count=1 oflag=direct,sync
1+0 레코드 들어옴
1+0 레코드 나감
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 5.5509 s, 193 MB/s
root@01e1478c8494:/app# free
              total        used        free      shared  buff/cache   available
Mem:        8040056      504800     1281772      342016     6253484     6937276
스왑:     1048572        1808     1046764
root@01e1478c8494:/app# rm testfile
```

---
## 스왑
사용 가능한 물리 메모리가 없어지면 OOM(out of memory) 상태가 된다.
스왑 기능을 사용하면 메모리가 고갈되어도 곧바로 OOM이 발생하는 걸 방지할 수 있다.
스왑: 저장 장치 일부를 일시적으로 메모리처럼 사용하는 방법
시스템의 물리 메모리가 고갈된 상태일 때 더 많은 메모리를 확보해야 한다면 사용 중인 물리 메모리 일부를 저장 장치로 옮기고 메모리에 빈 공간을 만든다. 데이터를 옮긴 영역을 스왑 영역이라고 한다.

물리 메모리 내부에서 한동안 사용되지 않을 거라고 커널이 판단한 메모리를 스왑 영역으로 옮긴다. (패이지 아웃 혹은 스왑 아웃)
대피시킨 페이지의 스왑 영역은 실제로는 커널 메모리 안에 기록된다.
커널은 비어 있는 메모리를 프로세스에 할당한다.

이후, 메모리 빈 공간이 생기면 프로세스가 앞서 페이지 아웃한 페이지에 접근하면 대응하는 데이터를 다시 메모리로 읽어온다.(페이지 인 혹은 스왑 인)

페이지 폴트 중에서 페이지 인 때문에 저장 장치에 접근이 발생하는 것(메이저 폴트, 마이너 폴트)
커널 내부 처리가 동작해서 성능에 영향을 준다.

스왑은 문제를 해결하는 것처럼 보이지만, 저장 장치에 접근하는 속도는 메모리 접근 속도에 비해 너무 느리다.
시스템 메모리가 늘 부족한 상태라면 페이지 인/페이지 아웃이 반복되는 스래싱 상태가 된다.
스래싱이 발생하면 그대로 멈추거나 OOM이 발생한다.

작업량을 줄이든 메모리를 확장해야 한다.

---
## 통계 정보

```bash
## kbdirty 값이 평소보다 크면 조만간 동기적으로 라이트 백 처리가 실행 될 가능성이 있음
root@01e1478c8494:/app# sar -r 1
Linux 5.15.49-linuxkit (01e1478c8494) 	2023년 09월 17일 	_aarch64_	(4 CPU)

14시 10분 48초 kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
14시 10분 49초   1286408   6942208    439464      5.47    351848   5198964   5062368     55.70    698984   5194660        12
14시 10분 50초   1286408   6942208    439464      5.47    351848   5198964   5062368     55.70    698984   5194752        12
14시 10분 51초   1286408   6942208    439464      5.47    351848   5198964   5062368     55.70    698984   5194752        12
...

평균값:    1286408   6942208    439464      5.47    351848   5198964   5062368     55.70    698984   5194721        12

# 페이지 인/페이지 아웃 관련 정보 확인
## 페이지 캐시나 버퍼 캐시가 디스크와 데이터를 주고 받는 것도 똑같이 페이지 인/페이지 아웃이라고 부른다.
root@01e1478c8494:/app# sar -B 1
Linux 5.15.49-linuxkit (01e1478c8494) 	2023년 09월 17일 	_aarch64_	(4 CPU)

14시 10분 59초  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff
14시 11분 00초      0.00      7.92      0.00      0.00     28.71      0.00      0.00      0.00      0.00
14시 11분 01초      0.00      0.00      1.00      0.00      6.00      0.00      0.00      0.00      0.00
...

평균값:       0.00      3.98      0.50      0.00     17.41      0.00      0.00      0.00      0.00

# 시스템의 스왑 영역 확인
root@01e1478c8494:/app# swapon --show
NAME  TYPE  SIZE USED PRIO
/swap file 1024M 1.8M   -2

# 스왑 영역 크기 확인
## Swap:(스왑:)이 스왑 영역 정보
## total은 KiB 단위의 스왑 영역 크기
## free은 그 중 비어 있는 영역 크기
root@01e1478c8494:/app# free
              total        used        free      shared  buff/cache   available
Mem:        8040056      499068     1286744      342036     6254244     6942988
스왑:     1048572        1808     1046764

# 현재 스왑 발생 확인(1초마다 데이터 출력)
## pswpin/s 필드: 페이지 인 횟수
## pswpout/s 필드: 페이지 아웃 횟수
## 시스템 성능이 갑자기 나빠졌을 때, 페이지 인/아수 횟수가 0이 아니라면 스왑이 원인일 수 있음
root@01e1478c8494:/app# sar -W 1
Linux 5.15.49-linuxkit (01e1478c8494) 	2023년 09월 17일 	_aarch64_	(4 CPU)

14시 12분 17초  pswpin/s pswpout/s
14시 12분 18초      0.00      0.00
14시 12분 19초      0.00      0.00
14시 12분 20초      0.00      0.00
...
평균값:       0.00      0.00

# 스왑 영역 이용 상황
## kbswpused 필드에 표시되는 스왑 영역 사용량 추세가 점점 늘어나면 위험 신호이다.
root@01e1478c8494:/app# sar -S 1
Linux 5.15.49-linuxkit (01e1478c8494) 	2023년 09월 17일 	_aarch64_	(4 CPU)

14시 12분 24초 kbswpfree kbswpused  %swpused  kbswpcad   %swpcad
14시 12분 25초   1046764      1808      0.17        36      1.99
14시 12분 26초   1046764      1808      0.17        36      1.99
14시 12분 27초   1046764      1808      0.17        36      1.99
14시 12분 28초   1046764      1808      0.17        36      1.99
...

평균값:    1046764      1808      0.17        36      1.99
```

- sar -r 명령어 중요 필드

| 필드명    | 의미                                                                                                      |
| --------- | --------------------------------------------------------------------------------------------------------- |
| kbmemfree | 비어 있는 메모리 용량(KiB)<br>페이지 캐시나 버퍼 캐시<br>스왑 영역은 포함 안됨                            |
| kbavail   | 사실 상 비어 있는 메모리 용량(KiB)<br>kbmemfree에 kbbuffers와 kbcached를 더한 값<br>스왑 영역은 포함 안됨 |
| kbbuffers | 버퍼 캐시 용량(KiB)                                                                                       |
| kbcached  | 페이지 캐시 용량(KiB)                                                                                     |
| kbdirty   | 더티한 상태의 페이지 캐시와 버퍼 캐시 용량(KiB)                                                                                                          |

- sar -B 명령어 중요 필드

| 필드      | 의미                                                                   |
| --------- | ---------------------------------------------------------------------- |
| pgpgin/s  | 초당 페이지 인 데이터량(KiB). 페이지 캐시, 버퍼 캐시, 스왑 전부 포함   |
| pgpgout/s | 초당 페이지 아웃 데이터량(KiB). 페이지 캐시, 버퍼 캐시, 스왑 전부 포함 |
| fault/s   | 페이지 폴트 수                                                         |
| majflt/s  | 페이지 폴트 중에서 페이지 인이 일어난 수(메이저 폴트)                                                                       |

---
#linux 
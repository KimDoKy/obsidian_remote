---
tags:
  - book
  - linux
---
- cgroup: 시스템 메모리나 CPU 같은 자원을 어떤 프로세스에 얼마나 재공할지 세밀하게 제어하는 기능
프로세스를 그룹으로 나눠서 각종 자원을 제어하는 개념에서 cgroup이라는 명칭이 붙음
시스템을 안정적으로 운용하기 위해서 특정 프로세스 또는 사용자가 자원을 독점하지 못하게 할 때 사용 등
## cgroup으로 제어 가능한 자원
cgroup은 자원마타 컨트롤러 라는 커널 내부 프로그램을 통해 자원을 제어함

| 컨트롤러명        | 제어하는 자원   | 설명                                      |
| ----------------- | --------------- | ----------------------------------------- |
| cpu 컨트롤러      | CPU             | 단위 시간당 CPU 사용 시간 등              |
| 메모리 컨트롤러   | 메모리          | 메모리 사용량이나 OOM Killer 영향 범위 등 |
| blkio 컨트롤러    | 블록 입출력     | 저장소 입출력 대역폭 등                   |
| 네트워크 컨트롤러 | 네트워크 입출력 | 네트워크 입출력 대역폭 등                 |                |                                           |

각 컨트롤러는 cgroupfs라는 특별한 파일 시스템을 사용함
이 파일 시스템은 컨트롤러별로 고유한 값이 되고, ubuntu의 경우 /sys/fs/cgroup/ 디렉터리 하에 컨트롤러에 대응하는 cgroup 파일 시스템이 마운트 됨
이 파일 시스템은 저장 장치에 존재하는 것이 아니라 메모리에만 존재하고, 접근하면 커널의 cgroup 기능을 사용할 수 있는 구조이다.
접근은 루트 사용자에게만 있다.

```bash
azureuser@myvm:~$ ls /sys/fs/cgroup
azure.slice             io.cost.qos
cgroup.controllers      io.pressure
cgroup.max.depth        io.prio.class
cgroup.max.descendants  io.stat
cgroup.pressure         memory.numa_stat
cgroup.procs            memory.pressure
cgroup.stat             memory.reclaim
cgroup.subtree_control  memory.stat
cgroup.threads          misc.capacity
cpu.pressure            proc-sys-fs-binfmt_misc.mount
cpu.stat                sys-fs-fuse-connections.mount
cpuset.cpus.effective   sys-kernel-config.mount
cpuset.mems.effective   sys-kernel-debug.mount
dev-hugepages.mount     sys-kernel-tracing.mount
dev-mqueue.mount        system.slice
init.scope              user.slice
io.cost.model
```

---
## CPU 사용 시간 제어

```bash
# 기본 그룹용 디렉터리 밑에 다시 디렉터리를 만들면 새로운 그룹을 만들 수 있다.
## 리눅스 커널은 CPU 컨트롤러로 생성한 그룹을 제어하기 위한 다양한 파일을 해당 디렉터리 아래에 자동 생성한다.
azureuser@myvm:/$ sudo mkdir -p /sys/fs/cgroup/cpu/test
azureuser@myvm:/$ ls /sys/fs/cgroup/cpu/test/
cgroup.controllers      cgroup.pressure         cpu.pressure
cgroup.events           cgroup.procs            cpu.stat
cgroup.freeze           cgroup.stat             io.pressure
cgroup.kill             cgroup.subtree_control  memory.pressure
cgroup.max.depth        cgroup.threads
cgroup.max.descendants  cgroup.type

## Azure VM으로 생성한 Ubuntu는 책과는 결과가 좀 다름...

- cpu.cfs_period_us, cpu.cfs_quota_us 파일을 조작하면 test 그룹에 할당하는 CPU 시간을 제어할 수 있음(CPU 대역폭 컨트롤러)
	- cpu.cfs_period_us는 동작을 제어할 기간 간격(ms)을 지정하고, 제어 대상이 되는 그룹 프로세스느 ㄴ기간 간격마다 cpu.cfs_quota_us 파일에 지정한 ms 시간 동안만 동작할 수 있다.
	- 기본값은 무제한(-1)이다.
	- 이런 상태로 프로그램을 실행하면 CPU를 100% 사용할 수 있다.
```

### 응용 예
- systemd를 사용하는 경우: 서비스별, 사용자별로 자동으로 그룹을 만듬. 각 그룹명은 system.slice와 user.slice이다.
- 도커나 쿠버네티스로 컨테이너를 관리하는 경우: 쿠버네티스 매니페스트에 자원 정보를 작성하거나 docker 명령어 인수에 컨테이너에  할당한 자원을 지정
- libvirt를 이용해서 가상 머신을 관리하는 경우: virt-manager로 설정하거나 가상 머신 설정 파일을 변경

---
cgroup v1은 유연성이 풍부하지만 각 컨트롤러 구현이 독립적이라 서로 연계하는 처리를 구현하기 어려움(ex. 블록 입출력 대역폭 제어는 직접 입출력을 사용할 때만 적용)
이런 문제를 해결하기 위해 cgroup v2가 나옴
각 컨트롤러를 연계해서 모든 컨트롤러에 공통인 계층 하나만 가짐
블록 입출력 문제가 해결되긴 했지만 대응하는 소프트웨어가  v1에 비해 적음

---
#linux 